from PyQt5 import QtGui, QtCore, QtWidgets
from PyQt5.QtWidgets import QSizePolicy
from ..plotbase import StackedLabel
from fflib import ff_time
from ..plotbase.grid import PlotGridObject
from ..dispwidgets.layouttools import BaseLayout
from ..plotwidgets.selectbase import  GeneralSelect
from ..plotbase import MagPyPlotItem, GraphicsLayout
from ..plotwidgets.plotuibase import GraphicsView
from .tracestats import TraceStats

from .dynamicspectra import DynamicSpectra, DynamicCohPha
from .spectra import Spectra
from .. import data_util

import numpy as np
from scipy import signal

class DetrendWindowUI(BaseLayout):
    def setupUI(self, Frame, window):
        Frame.setWindowTitle('Detrend')
        Frame.resize(1100, 700)
        layout = QtWidgets.QGridLayout(Frame)

        # Set up grid graphics layout
        self.gview = GraphicsView()
        self.gview.setSizePolicy(QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding))
        self.glw = GraphicsLayout()
        self.gview.setCentralItem(self.glw)
        self.glw.layout.setHorizontalSpacing(10)
        self.glw.layout.setContentsMargins(15, 10, 25, 10)
        layout.addWidget(self.gview, 1, 0, 1, 1)

        # Set up top settings/tools area
        self.btns = []
        toolsFrame = self.setupToolsLayout()

        settingsFrame = self.setupSettingsLayout()

        topLayout = QtWidgets.QHBoxLayout()
        topLayout.addWidget(toolsFrame)
        topLayout.addWidget(settingsFrame)
        topLayout.addStretch()
        layout.addLayout(topLayout, 0, 0, 1, 1)

        # Set up time edits at bottom of window
        timeLt, self.timeEdit, self.statusBar = self.getTimeStatusBar()
        layout.addLayout(timeLt, 2, 0, 1, 1)

    def setupSettingsLayout(self):
        frame = QtWidgets.QGroupBox('Settings')
        layout = QtWidgets.QHBoxLayout(frame)
        layout.setSpacing(10)

        # Set up box for choosing method
        typeTooltip = 'Method used for detrending\n'
        typeTooltip += 'Constant - Subtracts the average from the data\n'
        typeTooltip += 'Linear - Substracts the line generated by a least-squares fit on the data'

        self.detrendTypeBox = QtWidgets.QComboBox()
        self.detrendTypeBox.addItems(['Linear', 'Constant'])
        typeLbl = QtWidgets.QLabel('Method:')
        typeLbl.setToolTip(typeTooltip)

        # Link checkbox
        self.linkPlotsChk = QtWidgets.QCheckBox('Link Plots')
        self.linkPlotsChk.setChecked(True)

        self.updtBtn = QtWidgets.QPushButton('Update')

        for elem in [typeLbl, self.detrendTypeBox, self.linkPlotsChk, self.updtBtn]:
            layout.addWidget(elem)
        layout.addStretch()

        return frame

    def setupToolsLayout(self):
        frame = QtWidgets.QGroupBox('Tools')
        layout = QtWidgets.QHBoxLayout(frame)
        for tool in ['Spectra', 'Dynamic Spectra', 'Dynamic Coh/Pha']:
            btn = QtWidgets.QPushButton(tool)
            layout.addWidget(btn)
            self.btns.append(btn)
        return frame

class DetrendWindow(QtWidgets.QFrame, DetrendWindowUI):
    # Plots detrended data and mimics some of main window's functionality
    def __init__(self, window, parent=None):
        super(DetrendWindow, self).__init__(parent)
        self.window = window
        self.ui = DetrendWindowUI()
        self.ui.setupUI(self, window)

        # Initialize time parameters
        minTime, maxTime = window.getSelectionStartEndTimes()
        self.epoch = self.window.epoch

        # Store other related state information
        self.OS = window.OS
        self.currentEdit = self.window.currentEdit
        self.resolution = self.window.resolution
        self.tickOffset = self.window.tickOffset
        self.pens = window.pens
        self.edit = None
        self.traceStatsOnTop = True

        # State modified upon plotting
        self.currSelect = None
        self.savedRegion = None
        self.lastPlotStrings = []
        self.plotItems = []
        self.dtDatas = {}
        self.DATASTRINGS = []

        self.modifier = '_DT' # String appended to variable names

        # Analysis tools
        self.tools = {}
        self.tools['Spectra'] = None
        self.tools['DynSpectra'] = None
        self.tools['DynCohPha'] = None
        self.tools['Stats'] = None
        self.selectState = None

        # List of abbreviated versions of tool names
        self.abbrvNames = ['Spectra', 'DynSpectra', 'DynCohPha', 'Stats']
        self.toolFuncs = {} # Functions for starting up tools
        self.abbrvs = {} # Maps selection name to abbreviated version of tool name

        # List of tool names + their start functions
        self.toolNames = ['Spectra', 'Dynamic Spectra', 'Dynamic Coh/Pha', 'Stats']
        startFuncs = [self.startSpectra, self.startDynSpectra,
            self.startDynCohPha, self.startTraceStats]

        # Map tool names to abbreviations and start functions
        for toolName, abbrv, func in zip(self.toolNames, self.abbrvNames, startFuncs):
            self.abbrvs[toolName] = abbrv
            self.toolFuncs[abbrv] = func

        # Connect buttons to start functions
        for btn, func in zip(self.ui.btns, startFuncs[:-1]):
            btn.clicked.connect(func)

        self.ui.updtBtn.clicked.connect(self.update)
        self.ui.timeEdit.setupMinMax(self.window.getMinAndMaxDateTime())

    def getState(self):
        state = {}
        tool = self.getCurrentTool(False)
        if tool:
            name, regions = tool.getSelectionInfo()
            abbrv = self.abbrvs[name]
            toolObj = self.tools[abbrv]

            toolState = None
            if toolObj and hasattr(toolObj, 'getState'):
                toolState = toolObj.getState()
            tool = (abbrv, regions, toolState)

        state['tool'] = tool
        state['mode'] = self.getDetrendType()
        state['link'] = self.getLinkMode()
        return state

    def getToolObj(self, name):
        tool = None
        if name in self.abbrvs:
            tool = self.tools[self.abbrvs[name]]
        elif name in self.tools:
            tool = self.tools[name]

        return tool

    def loadState(self, state):
        # Set user-interface parameters
        self.setDetrendType(state['mode'])
        self.setLinkMode(state['link'])

        # Set tools to be loaded after initial update
        self.selectState = state['tool']

    def loadToolsFromState(self):
        # Loads tools from state information provided
        if self.selectState is None:
            return

        # Re-open tools and adjust regions
        name, regions, toolState = self.selectState
        self.toolFuncs[name](select=False)
        self.currSelect.loadToolFromState(regions, self.tools[name], toolState)

        # Clear state after initial update
        self.selectState = None

    def getDetrendType(self):
        return self.ui.detrendTypeBox.currentText()

    def setDetrendType(self, mode):
        self.ui.detrendTypeBox.setCurrentText(mode)

    def setLinkMode(self, link):
        self.ui.linkPlotsChk.setChecked(link)

    def getLinkMode(self):
        return self.ui.linkPlotsChk.isChecked()

    def closeEvent(self, event):
        self.closeSubWindows()
        self.window.endGeneralSelect()
        self.close()

    def endGeneralSelect(self):
        if self.currSelect:
            self.currSelect.closeAllRegions()
            self.currSelect = None

    def getCurrentTool(self, setTrace=True):
        if self.currSelect:
            return self.currSelect
        elif setTrace:
            self.openTraceStats()
            return self.currSelect
        else:
            return None

    def closeSubWindows(self):
        self.closeSpectra()
        self.closeDynSpectra()
        self.closeDynCohPha()
        self.closeTraceStats()

    def startTraceStats(self):
        self.openTraceStats(show=False)

    def startSpectra(self, sigHand=False, select=True):
        self.closeSubWindows()
        self.tools['Spectra'] = Spectra(self)
        self.currSelect = GeneralSelect(self, 'Single', 'Spectra', '#0000d1',
            self.tools['Spectra'].ui.timeEdit, self.openSpectra, 
            closeFunc=self.closeSpectra)
        if select:
            self.autoSelect()

    def openSpectra(self):
        if self.tools['Spectra']:
            self.tools['Spectra'].update()
            self.tools['Spectra'].show()

    def closeSpectra(self):
        if self.tools['Spectra']:
            self.tools['Spectra'].close()
            self.tools['Spectra'] = None

    def startDynSpectra(self, sigHand=False, select=True):
        self.closeSubWindows()
        self.tools['DynSpectra'] = DynamicSpectra(self)
        self.currSelect = GeneralSelect(self, 'Single', 'Dynamic Spectra', 
            '#cc0000', self.tools['DynSpectra'].ui.timeEdit, self.openDynSpectra, 
            self.updateDynSpectra, closeFunc=self.closeDynSpectra)
        if select:
            self.autoSelect()

    def openDynSpectra(self):
        if self.tools['DynSpectra']:
            self.tools['DynSpectra'].update()
            self.tools['DynSpectra'].show()

    def closeDynSpectra(self):
        if self.tools['DynSpectra']:
            self.tools['DynSpectra'].close()
            self.tools['DynSpectra'] = None

    def startDynCohPha(self, sigHand=False, select=True):
        self.closeSubWindows()
        self.tools['DynCohPha'] = DynamicCohPha(self)
        self.currSelect = GeneralSelect(self, 'Single', 'Dynamic Coh/Pha', 
            '#00d643', self.tools['DynCohPha'].ui.timeEdit, self.openDynCohPha, 
            self.updateDynCohPha, closeFunc=self.closeDynCohPha)
        if select:
            self.autoSelect()

    def openDynCohPha(self):
        if self.tools['DynCohPha']:
            self.tools['DynCohPha'].update()
            self.tools['DynCohPha'].show()

    def closeDynCohPha(self):
        if self.tools['DynCohPha']:
            self.tools['DynCohPha'].close()
            self.tools['DynCohPha'] = None

    def openTraceStats(self, show=True):
        self.closeSubWindows()
        self.tools['Stats'] = TraceStats(self)

        # Remove buttons unnecessary for detrend window
        viewBtn = self.tools['Stats'].ui.dispRangeBtn
        dtaBtn = self.tools['Stats'].ui.dtaBtn
        for elem in [viewBtn, dtaBtn]:
            self.tools['Stats'].ui.layout.removeWidget(elem)
            elem.deleteLater()

        self.currSelect = GeneralSelect(self, 'Adjusting', 'Stats', None,
            self.tools['Stats'].ui.timeEdit, updtFunc=self.updateTraceStats, 
            closeFunc=self.closeTraceStats, maxSteps=-1)

        if show:
            self.tools['Stats'].show()

    def closeTraceStats(self):
        if self.tools['Stats']:
            self.tools['Stats'].close()
            self.tools['Stats'] = None

    def updateTraceStats(self):
        if self.tools['Stats']:
            self.tools['Stats'].update()

    def updateDynCohPha(self):
        if self.tools['DynCohPha']:
            self.tools['DynCohPha'].updateParameters()

    def updateDynSpectra(self):
        if self.tools['DynSpectra']:
            self.tools['DynSpectra'].updateParameters()

    def autoSelect(self):
        # Auto-selects the entire range of detrended data
        if self.currSelect:
            self.currSelect.leftClick(self.tO-self.tickOffset, 0)
            self.currSelect.leftClick(self.tE-self.tickOffset, 0)

    def update(self):
        # Clear previous state
        self.closeSubWindows()
        self.lastPlotStrings = []
        self.plotItems = []
        self.dtDatas = {}

        # Set up grid elements
        self.ui.glw.clear()
        self.grid_object = PlotGridObject(self.window)
        self.pltGrd = self.grid_object.get_layout()
        self.ui.glw.addItem(self.grid_object, 1, 0, 1, 1)

        detrendType = self.getDetrendType().lower()

        plotNum = 0
        plotDataLists = []
        for pltInfo in self.window.getSelectedPlotInfo():
            # Extract variable names, edit nums, and pens from plot info
            plotStrings, pens = pltInfo
            dstrs, ens = [], []
            for dstr, en in plotStrings:
                if dstr == '':
                    continue
                dstrs.append(dstr)
                ens.append(en)

            # Build plot item
            # vb = SelectableViewBox(self, plotNum)
            plt = MagPyPlotItem(epoch=self.epoch)
            self.plotItems.append(plt)

            # # Build plot label
            colors = [pen for pen in pens]
            labels = [self.window.getLabel(dstr, en) + self.modifier for dstr, en in plotStrings]
            units = [self.window.UNITDICT[dstr] for dstr, en in plotStrings]
            label = StackedLabel(labels, colors, units)

            # Add to grid
            self.pltGrd.add_row()
            if plotNum == 0:
                plt.setTitle('Detrended Data')
            self.pltGrd[plotNum] = [label, plt]

            # Plot traces
            pltStrs = []
            pltDtas = []
            for dstr, pen, label in zip(dstrs, pens, labels):
                startIndex, endIndex = self.window.calcDataIndicesFromLines(dstr, 
                    self.window.currentEdit)

                # Get subset of data/times currently selected
                dta = self.window.getData(dstr, self.window.currentEdit)
                dtaSubset = dta[startIndex:endIndex]
                times = self.window.getTimes(dstr, self.window.currentEdit)[0]
                times = times - self.tickOffset
                timeSubset = times[startIndex:endIndex]

                # Detrend the data and store it in dictionary
                dtData = signal.detrend(dtaSubset, type=detrendType)
                self.dtDatas[label] = dtData
                pltDtas.append(dtData)

                # Plot and store for lastPlotStrings
                plt.plot(timeSubset, dtData, pen=pen, name=label)
                pltStrs.append((label, 0))
            plotDataLists.append(pltDtas)

            # # Update time range and axis appearance settings
            self.tO = timeSubset[0]
            self.tE = timeSubset[-1]
            self.minTime = self.tO
            self.maxTime = self.tE
            self.pltGrd.set_x_range(self.tO, self.tE)
            self.pltGrd.set_x_lim(self.tO, self.tE)

            self.lastPlotStrings.append(pltStrs)
            plotNum += 1

        # Save list of plot variables
        self.DATASTRINGS = list(self.dtDatas.keys())

        # Enable tracking and update grid
        map_func = lambda s : ff_time.tick_to_ts(s+self.tickOffset, self.epoch)
        self.ui.glw.enableTracking(True, textFuncs={'x':map_func}, viewWidget=self.ui.gview)
        self.ui.glw.update()

        # Link plots if necessary
        self.linkPlots()

        if self.selectState:
            self.loadToolsFromState()
        
        self.ui.glw.resize(1100-25, 560)

    def clearStatusMsg(self):
        return

    def linkPlots(self):
        plts = self.pltGrd.get_plots()
        if self.getLinkMode():
            self.grid_object.set_links([[i for i in range(len(plts))]])
        else:
            self.grid_object.set_links([])

    def adjustPlotAppr(self, plt):
        # Show all axes and hide all values except on left axis
        plt.showAxis('top')
        plt.showAxis('right')
        for ax in ['bottom', 'top', 'right']:
            plt.getAxis(ax).setStyle(showValues=False)
        plt.hideButtons()

    def getTimes(self, dstr, en):
        dstr = self.stripName(dstr)
        return self.window.getTimes(dstr, en)

    def getTimeIndex(self, dstr, en):
        dstr = self.stripName(dstr)
        return self.window.getTimeIndex(dstr, en)

    def getSelectionStartEndTimes(self, regNum=0):
        # Returns detrend window's selected regions
        if self.currSelect is None or self.currSelect.regions == []:
            return self.tO, self.tE
        t0, t1 = self.currSelect.regions[regNum].getRegion()
        return (t0,t1) if t0 <= t1 else (t1,t0)

    def getMinAndMaxDateTime(self):
        tO, tE = self.getSelectionStartEndTimes()
        minDate = ff_time.tick_to_date(tO, self.epoch)
        maxDate = ff_time.tick_to_date(tE, self.epoch)
        return minDate, maxDate

    def getData(self, dstr, en=None):
        # Get full dataset and fill the selected range with the detrended data
        # (for compatability purposes with analysis tools)
        if en is None:
            en = self.currentEdit
        dstr = self.stripName(dstr)

        a, b = self.window.calcDataIndicesFromLines(dstr, en)
        dta = self.window.getData(dstr, en)

        detrendDta = self.dtDatas[dstr+self.modifier]
        dta = dta.copy()
        dta[a:b] = detrendDta
        return dta

    def getPrunedData(self, dstr, en, a, b):
        dta = self.getData(dstr, en)[a:b]
        return dta[np.abs(dta) < self.window.errorFlag]

    def calcDataIndicesFromLines(self, dstr, editNumber, regNum=0):
        # Re-implemented from main window version to use detrend window's
        # functions that handle the modifier string in the dstr
        times = self.getTimes(dstr, editNumber)[0]
        t0, t1 = self.getSelectionStartEndTimes(regNum)
        i0 = data_util.get_data_index(times, t0)
        i1 = data_util.get_data_index(times, t1)
        if i1 > len(times)-1:
            i1 = len(times)-1
        assert(i0 <= i1)
        return i0,i1

    def getSelectedPlotInfo(self):
        # Adds the modifier to the plot info dstrs acquired from main window
        pltInfo = self.window.getSelectedPlotInfo()
        modifiedPltInfo = []
        for subPltInfo in pltInfo:
            subDstrs, pens = subPltInfo
            newPltStrLst = []
            for dstr, en in subDstrs:
                dstr = dstr + self.modifier
                newPltStrLst.append((dstr, en))
            modifiedPltInfo.append((newPltStrLst, pens))

        return modifiedPltInfo

    def getLabel(self, dstr, en):
        dstr = self.stripName(dstr)
        return self.window.getLabel(dstr, en) + self.modifier

    def getFileNameString(self, width):
        return self.window.getFileNameString(width)

    def stripName(self, dstr):
        newName = dstr
        if self.modifier in newName:
            newName = newName[:-len(self.modifier)]
        return newName

    def getAbbrvDstr(self, dstr):
        dstr = self.stripName(dstr)
        return self.window.getAbbrvDstr(dstr) + self.modifier

    def getDefaultPlotInfo(self):
        return self.window.getDefaultPlotInfo()

    def findVecGroups(self):
        return self.window.findVecGroups()
    
    def vecDict(self):
        vec_dict = {}
        for grp in self.findVecGroups():
            vec_dict[grp[0]] = grp
        return vec_dict

    def findPlottedVecGroups(self):
        return self.window.findPlottedVecGroups()

    def gridLeftClick(self, x, plotIndex, ctrlPressed):
        tool = self.getCurrentTool()
        if tool:
            tool.leftClick(x, plotIndex, ctrlPressed)
    
    def gridRightClick(self, plotIndex):
        tool = self.getCurrentTool(setTrace=False)

        # Apply right click to given tool general select object
        if tool:
            tool.rightClick(plotIndex)
            return True
        else:
            return False